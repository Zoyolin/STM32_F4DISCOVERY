création du projet : 
on utilisera la transmission de données par connexion rfid.
afin de pouvoir afficher ces mêmes données on gardera à disposition la connection série avec l'ordinateur.

Création du projet:
 on garde le module usart2
	- PA0 : USART2 CTS
	- PA1 : Usart2 RTS
	- PA2 : Usart2 Tx
	- PA3 : USART2 Rx	UART2 regarder PA3, PA2.
	- PA4 : Usart2 CK

	- PD3 : Usart2 CTS
	- PA4 : Usart2 RTS
	- PA5 : Usart2 Tx
	- PA6 : USART2 Rx
	- PA7 : Usart2 CK
 on ajoute le module SPI correspondant à l'emplacement click 1
on the :  uC	  Disco	 Click
	- PC1 	: AN	:S11
	- PE10 	: RST	:S10
	- PB13 	: CS	:Cs
	- PB12 	: SCK	:SCK
	- PB14 	: MISO	:SD0
	- PB15 	: MOSI	:SDI
	- +3.3v 
	- GND	
	- PA1  	: PWM	:INI
	- PE7  	: INT	:IND
	- PB11 	: RX uC	:TX CR95HF
	- PB10 	: TX	:RX //ici un croisement logique
	- PB8  	: SCL	:NC
	- PB7  	: SDA	:NC
	- +5v
	- GND
Selon le user_manual du click rfid, celui-ci est utilisé en communication SPI; Uart; FIFO buffer commands.
comme le module est configuré matériellement pour fonctionner en usart...
donc
	- PB11 	: USART3_RX	:TX 	UART3 regarder PB11 et PB10
	- PB10 	: USART3_TX	:RX
	- PB12	: USART3_CK	:CK
	- PB13	: USART3_RTS	:RTS
	- PB14	: USART3_CTS	:CTS

	- PD8 	: USART3_RX	:TX //pas utilisé
	- PD9	: USART3_TX	:RX
	- PD10	: USART3_CK	:CK
	- PD11	: USART3_RTS	:RTS	
	- PD12	: USART3_CTS	:CTS

	- PC10 	: USART3_RX	:TX //pas utilisé
	- PC11	: USART3_TX	:RX
	- PC12	: USART3_CK	:CK
on active donc la Usart3 dans l'interface CubeMX de STM32 Workbench.
afin de réaliser la procédure d'initialisation du click(CR95HF.pdf / PAGE 9 ) on recherche les broches du Micro Arm correspondant à IRQ_IN, SSI_0, SSI_1.
IRQ_IN	= 	PB10
SSI_0	=	PC1
SSI_1	=	PE10
VPS on peut rien y faire mais on a bien fait de vérifier (relié à masse~)
à présent on les configure en gpio output.
mais plus en detail :
comme la broche irq_in est maintenue en haute pour la pluspart du travail, on utilisera une pull up dans cette condition.
on configure donc la sortie en "open drain"

étude des réponses de la broche selon .Pull et .Mode de GPIO_InitStruct.
en OD : 
pull UP 	: niveaux de 3.28V
pull Down 	: niveaux de 2.96V
No pull 	: niveaux de 2.96V
en PP : 
pull UP 	: niveaux de 2.96V
pull Down 	: niveaux de 2.96V
No pull 	: niveaux de 2.96V

suite à cette étude on je confirme préférer utiliser le mode OD et la pull up sur les broches SSI_0 et SSI_1 afin d'avoir un signal C-C de 3.3V.

de manière relativement controlée, la séquence de démarrage est réalisée.

la réponse à pourquoi ces broches là tombent-elles à zéro est dans le fichier Driver/CMSIS/system_stm32f4xx.c
voilà le passage intéressant :
  /* Connect PEx pins to FMC Alternate function */
  GPIOE->AFR[0]  = 0xC00CC0CC;
  GPIOE->AFR[1]  = 0xCCCCCCCC;
  /* Configure PEx pins in Alternate function mode */ 
  GPIOE->MODER   = 0xAAAA828A;
  /* Configure PEx pins speed to 100 MHz */ 
  GPIOE->OSPEEDR = 0xFFFFC3CF;
  /* Configure PEx pins Output type to push-pull */  
  GPIOE->OTYPER  = 0x00000000;
  /* No pull-up, pull-down for PEx pins */ 
  GPIOE->PUPDR   = 0x00000000;
he bien non car on cherche à comprendre pourquoi la fonction MX_GPIO_Init passe le BSRR de chaque broche à 0 
ce serait commme ci dessous mais où?
GPIOE->BSRR =0;
mais j'ai pas trouvé.
dans HAL gpio.c, seule HAL_GPIO_WritePin touche à bsrr.
  

prise de photos de du démarrage 
photo 1 : CH1 = PC1 et CH2 = PE10
photo 2 : CH1 = PB10(IRQ_IN)  et  CH2 = PC1(SSI_0)
photo 2 : CH1 = PB10(IRQ_IN)  et  CH2 = PE10(SSI_1)

je vérifie mon montage série avec le projet série vers le pc.
Photo 4 : projet serial CH1 = PA3(Rx), CH2 = PA2(tx)



Configuration de la connexion série par la structure Handle:
typedef struct
{
  USART_TypeDef                 *Instance;        /*!< UART registers base address        */
  
  UART_InitTypeDef              Init;             /*!< UART communication parameters      */
  
  uint8_t                       *pTxBuffPtr;      /*!< Pointer to UART Tx transfer Buffer */
  
  uint16_t                      TxXferSize;       /*!< UART Tx Transfer size              */
  
  uint16_t                      TxXferCount;      /*!< UART Tx Transfer Counter           */
  
  uint8_t                       *pRxBuffPtr;      /*!< Pointer to UART Rx transfer Buffer */
  
  uint16_t                      RxXferSize;       /*!< UART Rx Transfer size              */
  
  uint16_t                      RxXferCount;      /*!< UART Rx Transfer Counter           */  
  
  DMA_HandleTypeDef             *hdmatx;          /*!< UART Tx DMA Handle parameters      */
    
  DMA_HandleTypeDef             *hdmarx;          /*!< UART Rx DMA Handle parameters      */
  
  HAL_LockTypeDef               Lock;             /*!< Locking object                     */

  __IO HAL_UART_StateTypeDef    gState;           /*!< UART state information related to global Handle management 
                                                       and also related to Tx operations.
                                                       This parameter can be a value of @ref HAL_UART_StateTypeDef */
  
  __IO HAL_UART_StateTypeDef    RxState;          /*!< UART state information related to Rx operations.
                                                       This parameter can be a value of @ref HAL_UART_StateTypeDef */
  
  __IO uint32_t                 ErrorCode;        /*!< UART Error code                    */

}UART_HandleTypeDef;
Dnas laquelle on trouve le champs init, lui même étant une structure :
typedef struct
{
  uint32_t BaudRate;                  /*!< This member configures the UART communication baud rate.
                                           The baud rate is computed using the following formula:
                                           - IntegerDivider = ((PCLKx) / (8 * (OVR8+1) * (huart->Init.BaudRate)))
                                           - FractionalDivider = ((IntegerDivider - ((uint32_t) IntegerDivider)) * 8 * (OVR8+1)) + 0.5 
                                           Where OVR8 is the "oversampling by 8 mode" configuration bit in the CR1 register. */

  uint32_t WordLength;                /*!< Specifies the number of data bits transmitted or received in a frame.
                                           This parameter can be a value of @ref UART_Word_Length */

  uint32_t StopBits;                  /*!< Specifies the number of stop bits transmitted.
                                           This parameter can be a value of @ref UART_Stop_Bits */

  uint32_t Parity;                    /*!< Specifies the parity mode.
                                           This parameter can be a value of @ref UART_Parity
                                           @note When parity is enabled, the computed parity is inserted
                                                 at the MSB position of the transmitted data (9th bit when
                                                 the word length is set to 9 data bits; 8th bit when the
                                                 word length is set to 8 data bits). */
 
  uint32_t Mode;                      /*!< Specifies whether the Receive or Transmit mode is enabled or disabled.
                                           This parameter can be a value of @ref UART_Mode */

  uint32_t HwFlowCtl;                 /*!< Specifies whether the hardware flow control mode is enabled
                                           or disabled.
                                           This parameter can be a value of @ref UART_Hardware_Flow_Control */
  
  uint32_t OverSampling;              /*!< Specifies whether the Over sampling 8 is enabled or disabled, to achieve higher speed (up to fPCLK/8).
                                           This parameter can be a value of @ref UART_Over_Sampling */ 
}UART_InitTypeDef;

ici les configs de init :
Uart3 pour le CR95HF
BaudRate	=57600
WordLength	=8
StopBits;	=2
Parity		=no
Mode		=full duplex
HwFlowCtl	=pas d'infos trouvée =none
OverSampling	=probablement pas incident car géré par hal

Uart2 pour le pc configuré depuis putty
BaudRate	=9600
WordLength	=8
StopBits;	=1
Parity		=none
Mode		=full duplex
HwFlowCtl	=
OverSampling	=probablement géré automatiquement

là les configs de handle :
en utilisant les fonctions HAL_UART_Receive et HAL_UART_Transmit on a pas besoin de ces lignes :
	//config perso :  **********************************************
	//	huart2.pTxBuffPtr = &buffer2 ;
	//	huart2.pRxBuffPtr = huart2.pTxBuffPtr;
	//**************************************************************
	//config perso :  **********************************************
	//	huart3.pTxBuffPtr = &bufferRx3 ;
	//	huart3.pRxBuffPtr = &bufferRx3 ;
	//**************************************************************
Bien évidement on configurera la broche PB10 utilisée par IRQ_IN en Tx de l'UART3 avant tout ceci !
Dans la fonction MX_USART3_UART_Init() :
	//ici on reconfigure à la main PB10 en broche pour l'UART.
	GPIO_InitTypeDef GPIO_InitStruct;
	GPIO_InitStruct.Pin = GPIO_PIN_10; 			//Tx_UART3
	GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;	//opendrain
	GPIO_InitStruct.Pull = GPIO_PULLUP;		//en pull up
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	GPIO_InitStruct.Alternate = GPIO_AF7_USART3; //broche dédiée à la fonction alternative UART3
	HAL_GPIO_Init(IRQ_IN_PORT, &GPIO_InitStruct); //on réinitialise

57600 bauds -> 1bit en 17.4us -> 8bits = 139.2us -> 11bits en 191.4us

on récupère la fonction d'attente de HAL et on la modifie pour s'en servir comme d'une attente attentive.
soit une écoute continue limitée par un watchdog.
void HAL_UART3_Receive_Delay(__IO uint32_t Delay)
{
	uint32_t tickstart = 0U;
	tickstart = HAL_GetTick();
	while(((HAL_GetTick() - tickstart) < Delay) && (Uart3_Rx_Status != HAL_OK) )
	{
		Uart3_Rx_Status = HAL_UART_Receive (&huart3, &bufferRx3, SizeRes3, TimeoutRes3); //reception
	}
}

Création du main_bis

modf aportées :
bufferRx3 est un pointeur
zonne de réception par défaut
unsigned char TmpRxZonne
et un tableau de stockage.

migration du code de IDN dans une fonction.

je commente des lignes dans mx_gpio_init

<<<0x00 0F 4E 46 43 20 46 53 32 4A 41 53 54 34 00 2A CE
15 caractères 

prochaine étape : intégrer les #define nécessaires pour pouvoir changer le CLICK de place.
